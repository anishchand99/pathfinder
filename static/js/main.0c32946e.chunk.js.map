{"version":3,"sources":["PathFinder/Node.js","PathFinder/Navbar.js","algorithms/aStar.js","algorithms/bfs.js","algorithms/dfs.js","algorithms/dijkstra.js","constants.js","PathFinder/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["Node","onMouseDown","e","node","console","log","document","querySelector","setState","isMouseDown","isMouseUp","onMouseUp","target","className","onMouseOver","state","getElementById","props","column","row","style","backgroundColor","onMouseEnter","didMouseEnter","onMouseLeave","didMouseLeave","onDragStart","dataTransfer","setData","onDragOver","preventDefault","onDrop","changeStartNode","changeEndNode","resetCSS","data","getData","didMouseMove","isDragable","this","isStart","isFinish","isWall","makeWall","extraClassName","draggable","id","Component","Navbar","getAlgorithmType","selectAlgo","value","getSpeedValue","selectSpeed","onChange","sortQueue","minQueue","sort","a","b","distance","getNeighbors","currentNode","grid","neighborList","push","length","dijkstra","startNode","endNode","visitedNodes","unvisitedNodes","nodes","getAllNodes","getClosestNode","Infinity","isVisited","neighbor","previousNode","A","B","shift","getShortestPath","shortestPath","reverse","initialState","startNodeCol","startNodeRow","endNodeCol","endNodeRow","algo","speed","wallDict","Map","i","j","set","createWallDictionary","PathFinder","algorithm","speedX","updatedWall","alreadyIsWall","get","drawInitialGrid","bool","disabled","freezeButtons","queue","includes","bfs","stack","pop","dfs","start","end","Math","abs","aStar","removeCSS","animateAlgorithm","setTimeout","displayShortestPath","onClick","visualizeAlgorithm","map","rowIndex","key","coln","colnIndex","currentColumn","createNewNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0c32946e.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nclass Node extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      isMouseUp: true,\r\n      isMouseDown: false,\r\n      didMouseEnter: false,\r\n      didMouseMove: false,\r\n      didMouseLeave: false,\r\n    };\r\n  }\r\n  onMouseDown = (e, node) => {\r\n    console.log(document.querySelector(\".grid\"));\r\n    this.setState({ isMouseDown: true, isMouseUp: false });\r\n  };\r\n  onMouseUp = (e, node) => {\r\n    console.log(\"up\");\r\n    console.log(e.target.className);\r\n    this.setState({ isMouseUp: true, isMouseDown: false });\r\n  };\r\n  onMouseOver = (e, node) => {\r\n    // const [makeWall] = this.props;\r\n    if (this.state.isMouseDown === true) {\r\n      // makeWall(node);\r\n      console.log(node);\r\n      console.log(\r\n        document.getElementById(`node-${node.props.column}-${node.props.row}`)\r\n      );\r\n      document.getElementById(\r\n        `node-${node.props.column}-${node.props.row}`\r\n      ).style.backgroundColor = \"purple\";\r\n    }\r\n  };\r\n  onMouseEnter = () => {\r\n    this.setState({ didMouseEnter: true });\r\n  };\r\n  onMouseLeave = () => {\r\n    this.setState({ didMouseLeave: true, didMouseEnter: false });\r\n  };\r\n  onDragStart = (e, node) => {\r\n    e.dataTransfer.setData(\r\n      \"text\",\r\n      `node-${node.props.column}-${node.props.row}`\r\n    );\r\n  };\r\n  onDragOver = (e) => {\r\n    e.preventDefault();\r\n  };\r\n  onDrop = (e, node) => {\r\n    const { changeStartNode, changeEndNode, resetCSS } = this.props;\r\n    //id of the 'soon to be previous' startNode/endNode, current startNode/endNode that will be previous after drag n drop\r\n    let data = e.dataTransfer.getData(\"text\");\r\n    if (document.getElementById(data).className === \"nodestart\") {\r\n      document.querySelector(`.nodestart`).className = \"node\";\r\n      document.getElementById(\r\n        `node-${node.props.column}-${node.props.row}`\r\n      ).className = \"nodestart\";\r\n      changeStartNode(node);\r\n    }\r\n    if (document.getElementById(data).className === \"nodefinish\") {\r\n      document.querySelector(`.nodefinish`).className = \"node\";\r\n      document.getElementById(\r\n        `node-${node.props.column}-${node.props.row}`\r\n      ).className = \"nodefinish\";\r\n      changeEndNode(node);\r\n    }\r\n    resetCSS();\r\n  };\r\n  render() {\r\n    const { column, row, isStart, isFinish, isWall, makeWall } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"finish\"\r\n      : isStart\r\n      ? \"start\"\r\n      : isWall\r\n      ? \"wall\"\r\n      : \"\";\r\n    let isDragable;\r\n    if (isStart) {\r\n      isDragable = true;\r\n    } else if (isFinish) {\r\n      isDragable = true;\r\n    } else {\r\n      isDragable = false;\r\n    }\r\n    return (\r\n      <div\r\n        draggable={isDragable}\r\n        id={`node-${column}-${row}`}\r\n        className={`node${extraClassName}`}\r\n        onMouseDown={(e) => makeWall(this)}\r\n        onDragStart={(e) => this.onDragStart(e, this)}\r\n        onDragOver={(e) => this.onDragOver(e)}\r\n        onDrop={(e) => this.onDrop(e, this)}\r\n      />\r\n    );\r\n  }\r\n}\r\nexport default Node;\r\n","import React, { Component } from 'react';\r\nimport './Navbar.css';\r\nclass Navbar extends Component {\r\n  constructor() {\r\n    super();\r\n  }\r\n  getAlgorithmType = () => {\r\n    const { selectAlgo } = this.props;\r\n    selectAlgo(document.getElementById('algorithm-type').value);\r\n  };\r\n  getSpeedValue = () => {\r\n    const { selectSpeed } = this.props;\r\n    selectSpeed(document.getElementById('speed-val').value);\r\n  };\r\n  render() {\r\n    return (\r\n      <div className='navBar'>\r\n        <div className='split'>\r\n          <span>\r\n            Algorithms&nbsp;\r\n            <select id='algorithm-type' onChange={this.getAlgorithmType}>\r\n              <option value='dijkstra'>Dijkstra</option>\r\n              <option value='breadthFirst'>Breadth First</option>\r\n              <option value='depthFirst'>Depth First</option>\r\n              <option value='aStar'>A Star</option>\r\n            </select>\r\n          </span>\r\n          <span>\r\n            Speed&nbsp;\r\n            <select id='speed-val' onChange={this.getSpeedValue}>\r\n              <option value='500'>1X</option>\r\n              <option value='100'>5X</option>\r\n              <option value='1'>Instant</option>\r\n            </select>\r\n          </span>\r\n          <span>\r\n            <div className='startNode'></div>\r\n            Start Node\r\n          </span>\r\n          <span>\r\n            <div className='endNode'></div>\r\n            End Node\r\n          </span>\r\n        </div>\r\n        <div className='split'>\r\n          <span>\r\n            <div className='wall'></div>\r\n            Wall\r\n          </span>\r\n\r\n          <span>\r\n            <div className='visitedNode'></div>\r\n            Visited Nodes\r\n          </span>\r\n          <span>\r\n            <div className='unvisitedNode'></div>\r\n            Unvisited Nodes\r\n          </span>\r\n          <span>\r\n            <div className='path'></div>\r\n            Path\r\n          </span>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\nexport default Navbar;\r\n","export function aStar(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let minQueue = [startNode];\r\n  let currentNode;\r\n  while (minQueue.length !== 0) {\r\n    currentNode = minQueue.shift();\r\n    if (currentNode.isWall) continue;\r\n    if (currentNode === endNode) return visitedNodes;\r\n    if (!visitedNodes.includes(currentNode)) {\r\n      if (!currentNode.isWall) {\r\n        visitedNodes.push(currentNode);\r\n      }\r\n    }\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    for (const node of neighborList) {\r\n      if (!visitedNodes.includes(node)) {\r\n        node.previousNode = currentNode;\r\n        node.distance = getManhattanDistance(node, endNode);\r\n        if (!node.isWall) {\r\n          minQueue.push(node);\r\n        }\r\n      }\r\n    }\r\n    //sort by Manhattan distance (min priority queue)\r\n    sortQueue(minQueue);\r\n    if (minQueue.length === 0) {\r\n      return visitedNodes;\r\n    }\r\n  }\r\n}\r\n\r\n//sort by Manhattan distance (min priority queue)\r\nfunction sortQueue(minQueue) {\r\n  minQueue.sort(function (a, b) {\r\n    return a.distance - b.distance;\r\n  });\r\n}\r\n\r\n//Manhattan distance => |x - x1| + |y - y1|\r\nfunction getManhattanDistance(start, end) {\r\n  return Math.abs(start.row - end.row) + Math.abs(start.column - end.column);\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n","export function bfs(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let queue = [startNode];\r\n  let currentNode;\r\n  while (queue.length !== 0) {\r\n    currentNode = queue.shift();\r\n    if (currentNode.isWall) continue;\r\n    if (!visitedNodes.includes(currentNode)) {\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    if (currentNode === endNode) return visitedNodes;\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    for (const node of neighborList) {\r\n      if (!visitedNodes.includes(node)) {\r\n        node.previousNode = currentNode;\r\n        if (!node.isWall) {\r\n          queue.push(node);\r\n        }\r\n      }\r\n    }\r\n    if (queue.length === 0) {\r\n      return visitedNodes;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n","export function dfs(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let stack = [startNode];\r\n  let currentNode;\r\n  while (stack.length !== 0) {\r\n    currentNode = stack.pop();\r\n    if (currentNode.isWall) continue;\r\n    if (!visitedNodes.includes(currentNode)) {\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    if (currentNode === endNode) return visitedNodes;\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    for (const node of neighborList) {\r\n      if (!visitedNodes.includes(node)) {\r\n        node.previousNode = currentNode;\r\n        if (!node.isWall) {\r\n          stack.push(node);\r\n        }\r\n      }\r\n    }\r\n    if (stack.length === 0) {\r\n      return visitedNodes;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n","export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length > 0) {\r\n    //   start at the start node and susequently get the closest neighbor\r\n    const currentNode = getClosestNode(unvisitedNodes);\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    if (currentNode.isWall) continue;\r\n    if (currentNode.distance === Infinity) return visitedNodes;\r\n    currentNode.isVisited = true;\r\n    visitedNodes.push(currentNode);\r\n    if (currentNode === endNode) return visitedNodes;\r\n    for (const neighbor of neighborList) {\r\n      let distance = currentNode.distance + 1;\r\n      if (distance < neighbor.distance) {\r\n        neighbor.distance = distance;\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n\r\nfunction getClosestNode(unvisitedNodes) {\r\n  //arrange in ascending order by distance\r\n  unvisitedNodes.sort((A, B) => A.distance - B.distance);\r\n  //remove closestNode from unvisited nodes\r\n  const node = unvisitedNodes.shift();\r\n  return node;\r\n}\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const column of grid) {\r\n    for (const node of column) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\nexport function getShortestPath(startNode, endNode) {\r\n  let shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return shortestPath.reverse();\r\n}\r\n","export const START_NODE_COL = 20;\r\nexport const START_NODE_ROW = 10;\r\nexport const END_NODE_COL = 12;\r\nexport const END_NODE_ROW = 10;\r\nexport const GRID_COLS = 50;\r\nexport const GRID_ROWS = 20;\r\n","import React, { Component } from 'react';\r\nimport Node from './Node.js';\r\nimport './PathFinder.css';\r\nimport Navbar from './Navbar';\r\nimport { aStar } from '../algorithms/aStar';\r\nimport { bfs } from '../algorithms/bfs';\r\nimport { dfs } from '../algorithms/dfs';\r\nimport { dijkstra, getShortestPath } from '../algorithms/dijkstra';\r\nimport {\r\n  START_NODE_COL,\r\n  START_NODE_ROW,\r\n  END_NODE_COL,\r\n  END_NODE_ROW,\r\n  GRID_COLS,\r\n  GRID_ROWS,\r\n} from '../constants';\r\nconst createWallDictionary = () => {\r\n  let wallDict = new Map();\r\n  for (let i = 0; i < GRID_COLS; i++) {\r\n    for (let j = 0; j < GRID_ROWS; j++) {\r\n      wallDict.set(`${i}-${j}`, false);\r\n    }\r\n  }\r\n  return wallDict;\r\n};\r\nlet wallDictionary = createWallDictionary();\r\nconst initialState = {\r\n  grid: [],\r\n  startNodeCol: START_NODE_COL,\r\n  startNodeRow: START_NODE_ROW,\r\n  endNodeCol: END_NODE_COL,\r\n  endNodeRow: END_NODE_ROW,\r\n  algo: 'dijkstra',\r\n  speed: 500,\r\n  wallDict: wallDictionary,\r\n};\r\nclass PathFinder extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = initialState;\r\n  }\r\n  componentDidMount() {\r\n    const grid = drawInitialGrid(this.state);\r\n    this.setState({ grid: grid });\r\n  }\r\n  freezeButtons(bool) {\r\n    let startButton = document.getElementById('start');\r\n    startButton.disabled = bool;\r\n    let resetButton = document.getElementById('reset');\r\n    resetButton.disabled = bool;\r\n  }\r\n  selectAlgo = (algorithm) => {\r\n    this.setState({ algo: algorithm });\r\n  };\r\n  selectSpeed = (speedX) => {\r\n    this.setState({ speed: speedX });\r\n  };\r\n  visualizeAlgorithm() {\r\n    this.freezeButtons(true);\r\n    const {\r\n      grid,\r\n      startNodeCol,\r\n      startNodeRow,\r\n      endNodeCol,\r\n      endNodeRow,\r\n      algo,\r\n    } = this.state;\r\n    const startNode = grid[startNodeCol][startNodeRow];\r\n    const endNode = grid[endNodeCol][endNodeRow];\r\n    let visitedNodes = [];\r\n    let shortestPath;\r\n    if (algo === 'dijkstra') {\r\n      visitedNodes = dijkstra(grid, startNode, endNode);\r\n      shortestPath = getShortestPath(startNode, endNode);\r\n    } else if (algo === 'breadthFirst') {\r\n      visitedNodes = bfs(grid, startNode, endNode);\r\n      shortestPath = getShortestPath(startNode, endNode);\r\n    } else if (algo === 'depthFirst') {\r\n      visitedNodes = dfs(grid, startNode, endNode);\r\n      shortestPath = visitedNodes;\r\n    } else {\r\n      visitedNodes = aStar(grid, startNode, endNode);\r\n      shortestPath = getShortestPath(startNode, endNode);\r\n    }\r\n    this.removeCSS();\r\n    this.animateAlgorithm(visitedNodes, startNode, endNode, shortestPath);\r\n  }\r\n\r\n  //remove the CSS of the nodes after the first use of visualize button\r\n  removeCSS() {\r\n    while (\r\n      document.querySelector(`.node-Visited`) != null ||\r\n      document.querySelector(`.node-Path`) != null\r\n    ) {\r\n      if (document.querySelector(`.node-Visited`) != null) {\r\n        document.querySelector(`.node-Visited`).className = 'node';\r\n      }\r\n      if (document.querySelector(`.node-Path`) != null) {\r\n        document.querySelector(`.node-Path`).className = 'node';\r\n      }\r\n    }\r\n  }\r\n  animateAlgorithm(visitedNodes, startNode, endNode, shortestPath) {\r\n    const { speed } = this.state;\r\n    for (let i = 0; i < visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length - 1) {\r\n        setTimeout(() => {\r\n          this.displayShortestPath(shortestPath, startNode, endNode);\r\n        }, speed * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodes[i];\r\n        if (node !== startNode && node !== endNode) {\r\n          document.getElementById(`node-${node.column}-${node.row}`).className =\r\n            'node-Visited';\r\n        }\r\n      }, speed * i);\r\n    }\r\n  }\r\n  displayShortestPath(shortestPath, startNode, endNode) {\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      const node = shortestPath[i];\r\n      if (node !== startNode && node !== endNode) {\r\n        document.getElementById(`node-${node.column}-${node.row}`).className =\r\n          'node-Path';\r\n      }\r\n    }\r\n    this.freezeButtons(false);\r\n  }\r\n  makeWall = (node) => {\r\n    const { startNodeCol, startNodeRow, endNodeCol, endNodeRow } = this.state;\r\n    let updatedWall = this.state.wallDict;\r\n    //check if the node is already a wall\r\n    const alreadyIsWall = this.state.wallDict.get(\r\n      `${node.props.column}-${node.props.row}`\r\n    );\r\n    //check if condition: don't make wall if it is a start node or end node\r\n    if (\r\n      !(\r\n        (node.props.row === startNodeRow &&\r\n          node.props.column === startNodeCol) ||\r\n        (node.props.row === endNodeRow && node.props.column === endNodeCol)\r\n      )\r\n    ) {\r\n      //check if condition: if already a wall, remove the wall\r\n      if (alreadyIsWall) {\r\n        updatedWall.set(`${node.props.column}-${node.props.row}`, false);\r\n      } else {\r\n        updatedWall.set(`${node.props.column}-${node.props.row}`, true);\r\n      }\r\n    }\r\n    this.setState(\r\n      {\r\n        wallDict: updatedWall,\r\n      },\r\n      () => {\r\n        const grid = drawInitialGrid(this.state);\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  };\r\n  changeStartNode = (node) => {\r\n    this.setState(\r\n      {\r\n        startNodeCol: node.props.column,\r\n        startNodeRow: node.props.row,\r\n      },\r\n      () => {\r\n        const grid = drawInitialGrid(this.state);\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  };\r\n  changeEndNode = (node) => {\r\n    this.setState(\r\n      {\r\n        endNodeCol: node.props.column,\r\n        endNodeRow: node.props.row,\r\n      },\r\n      () => {\r\n        const grid = drawInitialGrid(this.state);\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  };\r\n\r\n  //reset the CSS animations to go to fresh grid, used in the reset button\r\n  resetCSS() {\r\n    while (\r\n      document.querySelector(`.node-Visited`) != null ||\r\n      document.querySelector(`.node-Path`) != null ||\r\n      document.querySelector(`.nodewall`) != null\r\n    ) {\r\n      if (document.querySelector(`.node-Visited`) != null) {\r\n        document.querySelector(`.node-Visited`).className = 'node';\r\n      }\r\n      if (document.querySelector(`.node-Path`) != null) {\r\n        document.querySelector(`.node-Path`).className = 'node';\r\n      }\r\n      if (document.querySelector(`.nodewall`) != null) {\r\n        document.querySelector(`.nodewall`).className = 'node';\r\n      }\r\n    }\r\n  }\r\n  render() {\r\n    const { grid } = this.state;\r\n    return (\r\n      <div className='container'>\r\n        <Navbar\r\n          selectAlgo={this.selectAlgo}\r\n          selectSpeed={this.selectSpeed}\r\n        ></Navbar>\r\n        <button id='start' onClick={() => this.visualizeAlgorithm()}>\r\n          Visualize!\r\n        </button>\r\n        <button id='reset' onClick={() => this.resetCSS()}>\r\n          Reset!\r\n        </button>\r\n        <div className='grid'>\r\n          {grid.map((row, rowIndex) => {\r\n            return (\r\n              <div key={rowIndex}>\r\n                {row.map((coln, colnIndex) => {\r\n                  const { row, column, isStart, isFinish, isWall } = coln;\r\n                  return (\r\n                    <Node\r\n                      key={colnIndex}\r\n                      row={row}\r\n                      column={column}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      changeStartNode={this.changeStartNode}\r\n                      changeEndNode={this.changeEndNode}\r\n                      makeWall={this.makeWall}\r\n                      resetCSS={this.resetCSS}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst drawInitialGrid = (state) => {\r\n  const grid = [];\r\n  for (let column = 0; column < GRID_COLS; column++) {\r\n    let currentColumn = [];\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n      currentColumn.push(createNewNode(row, column, state));\r\n    }\r\n    grid.push(currentColumn);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNewNode = (row, column, state) => {\r\n  const {\r\n    startNodeCol,\r\n    startNodeRow,\r\n    endNodeCol,\r\n    endNodeRow,\r\n    wallDict,\r\n  } = state;\r\n  return {\r\n    column,\r\n    row,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n    isVisited: false,\r\n    isWall: wallDict.get(`${column}-${row}`),\r\n    isStart: column === startNodeCol && row === startNodeRow,\r\n    isFinish: column === endNodeCol && row === endNodeRow,\r\n  };\r\n};\r\n\r\nexport default PathFinder;\r\n\r\n//Try a boolean vs string dicitonary string will be the coln and row and boolean is isWall.\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathFinder from \"./PathFinder/PathFinder\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathFinder></PathFinder>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}