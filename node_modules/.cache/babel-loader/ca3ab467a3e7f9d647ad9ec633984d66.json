{"ast":null,"code":"export function aStar(grid, startNode, endNode) {\n  const visitedNodes = [];\n  let minQueue = [startNode];\n  let currentNode;\n\n  while (minQueue.length !== 0) {\n    if (queue.length == 0) {\n      return visitedNodes;\n    }\n\n    currentNode = minQueue.shift();\n    if (currentNode.isWall) continue;\n    if (currentNode === endNode) return visitedNodes;\n\n    if (!visitedNodes.includes(currentNode)) {\n      visitedNodes.push(currentNode);\n    }\n\n    const neighborList = getNeighbors(currentNode, grid);\n\n    for (const node of neighborList) {\n      if (!visitedNodes.includes(node)) {\n        node.previousNode = currentNode;\n        node.distance = getManhattanDistance(node, endNode);\n        minQueue.push(node);\n      }\n    } //sort by Manhattan distance (min priority queue)\n\n\n    sortQueue(minQueue);\n  }\n} //sort by Manhattan distance (min priority queue)\n\nfunction sortQueue(minQueue) {\n  minQueue.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n} //Manhattan distance => |x - x1| + |y - y1|\n\n\nfunction getManhattanDistance(start, end) {\n  return Math.abs(start.row - end.row) + Math.abs(start.column - end.column);\n}\n\nfunction getNeighbors(currentNode, grid) {\n  const neighborList = [];\n  const column = currentNode.column,\n        row = currentNode.row;\n  if (column > 0) neighborList.push(grid[column - 1][row]);\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\n  if (row > 0) neighborList.push(grid[column][row - 1]);\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\n  return neighborList;\n}","map":{"version":3,"sources":["C:/Users/Anish/Documents/PROJECTS/pathfinding/pathfinder/src/algorithms/aStar.js"],"names":["aStar","grid","startNode","endNode","visitedNodes","minQueue","currentNode","length","queue","shift","isWall","includes","push","neighborList","getNeighbors","node","previousNode","distance","getManhattanDistance","sortQueue","sort","a","b","start","end","Math","abs","row","column"],"mappings":"AAAA,OAAO,SAASA,KAAT,CAAeC,IAAf,EAAqBC,SAArB,EAAgCC,OAAhC,EAAyC;AAC9C,QAAMC,YAAY,GAAG,EAArB;AACA,MAAIC,QAAQ,GAAG,CAACH,SAAD,CAAf;AACA,MAAII,WAAJ;;AACA,SAAOD,QAAQ,CAACE,MAAT,KAAoB,CAA3B,EAA8B;AAC5B,QAAIC,KAAK,CAACD,MAAN,IAAgB,CAApB,EAAuB;AACrB,aAAOH,YAAP;AACD;;AACDE,IAAAA,WAAW,GAAGD,QAAQ,CAACI,KAAT,EAAd;AACA,QAAIH,WAAW,CAACI,MAAhB,EAAwB;AACxB,QAAIJ,WAAW,KAAKH,OAApB,EAA6B,OAAOC,YAAP;;AAC7B,QAAI,CAACA,YAAY,CAACO,QAAb,CAAsBL,WAAtB,CAAL,EAAyC;AACvCF,MAAAA,YAAY,CAACQ,IAAb,CAAkBN,WAAlB;AACD;;AACD,UAAMO,YAAY,GAAGC,YAAY,CAACR,WAAD,EAAcL,IAAd,CAAjC;;AACA,SAAK,MAAMc,IAAX,IAAmBF,YAAnB,EAAiC;AAC/B,UAAI,CAACT,YAAY,CAACO,QAAb,CAAsBI,IAAtB,CAAL,EAAkC;AAChCA,QAAAA,IAAI,CAACC,YAAL,GAAoBV,WAApB;AACAS,QAAAA,IAAI,CAACE,QAAL,GAAgBC,oBAAoB,CAACH,IAAD,EAAOZ,OAAP,CAApC;AACAE,QAAAA,QAAQ,CAACO,IAAT,CAAcG,IAAd;AACD;AACF,KAjB2B,CAkB5B;;;AACAI,IAAAA,SAAS,CAACd,QAAD,CAAT;AACD;AACF,C,CAED;;AACA,SAASc,SAAT,CAAmBd,QAAnB,EAA6B;AAC3BA,EAAAA,QAAQ,CAACe,IAAT,CAAc,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC5B,WAAOD,CAAC,CAACJ,QAAF,GAAaK,CAAC,CAACL,QAAtB;AACD,GAFD;AAGD,C,CAED;;;AACA,SAASC,oBAAT,CAA8BK,KAA9B,EAAqCC,GAArC,EAA0C;AACxC,SAAOC,IAAI,CAACC,GAAL,CAASH,KAAK,CAACI,GAAN,GAAYH,GAAG,CAACG,GAAzB,IAAgCF,IAAI,CAACC,GAAL,CAASH,KAAK,CAACK,MAAN,GAAeJ,GAAG,CAACI,MAA5B,CAAvC;AACD;;AAED,SAASd,YAAT,CAAsBR,WAAtB,EAAmCL,IAAnC,EAAyC;AACvC,QAAMY,YAAY,GAAG,EAArB;AADuC,QAE/Be,MAF+B,GAEftB,WAFe,CAE/BsB,MAF+B;AAAA,QAEvBD,GAFuB,GAEfrB,WAFe,CAEvBqB,GAFuB;AAGvC,MAAIC,MAAM,GAAG,CAAb,EAAgBf,YAAY,CAACD,IAAb,CAAkBX,IAAI,CAAC2B,MAAM,GAAG,CAAV,CAAJ,CAAiBD,GAAjB,CAAlB;AAChB,MAAIC,MAAM,GAAG3B,IAAI,CAACM,MAAL,GAAc,CAA3B,EAA8BM,YAAY,CAACD,IAAb,CAAkBX,IAAI,CAAC2B,MAAM,GAAG,CAAV,CAAJ,CAAiBD,GAAjB,CAAlB;AAC9B,MAAIA,GAAG,GAAG,CAAV,EAAad,YAAY,CAACD,IAAb,CAAkBX,IAAI,CAAC2B,MAAD,CAAJ,CAAaD,GAAG,GAAG,CAAnB,CAAlB;AACb,MAAIA,GAAG,GAAG1B,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA3B,EAA8BM,YAAY,CAACD,IAAb,CAAkBX,IAAI,CAAC2B,MAAD,CAAJ,CAAaD,GAAG,GAAG,CAAnB,CAAlB;AAC9B,SAAOd,YAAP;AACD","sourcesContent":["export function aStar(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let minQueue = [startNode];\r\n  let currentNode;\r\n  while (minQueue.length !== 0) {\r\n    if (queue.length == 0) {\r\n      return visitedNodes;\r\n    }\r\n    currentNode = minQueue.shift();\r\n    if (currentNode.isWall) continue;\r\n    if (currentNode === endNode) return visitedNodes;\r\n    if (!visitedNodes.includes(currentNode)) {\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    for (const node of neighborList) {\r\n      if (!visitedNodes.includes(node)) {\r\n        node.previousNode = currentNode;\r\n        node.distance = getManhattanDistance(node, endNode);\r\n        minQueue.push(node);\r\n      }\r\n    }\r\n    //sort by Manhattan distance (min priority queue)\r\n    sortQueue(minQueue);\r\n  }\r\n}\r\n\r\n//sort by Manhattan distance (min priority queue)\r\nfunction sortQueue(minQueue) {\r\n  minQueue.sort(function (a, b) {\r\n    return a.distance - b.distance;\r\n  });\r\n}\r\n\r\n//Manhattan distance => |x - x1| + |y - y1|\r\nfunction getManhattanDistance(start, end) {\r\n  return Math.abs(start.row - end.row) + Math.abs(start.column - end.column);\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}