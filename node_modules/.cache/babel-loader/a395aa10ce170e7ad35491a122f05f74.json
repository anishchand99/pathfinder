{"ast":null,"code":"export function dijkstra(grid, startNode, endNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length > 0) {\n    //   start at the start node and susequently get the closest neighbor\n    const currentNode = getClosestNode(unvisitedNodes);\n    const neighborList = getNeighbors(currentNode, grid);\n    if (currentNode.isWall) continue;\n    if (currentNode.distance === Infinity) return visitedNodes;\n    currentNode.isVisited = true;\n    visitedNodes.push(currentNode);\n    if (currentNode === endNode) return visitedNodes;\n\n    for (const neighbor of neighborList) {\n      let distance = currentNode.distance + 1;\n      console.log(distance);\n\n      if (distance < neighbor.distance) {\n        neighbor.distance = distance;\n        neighbor.previousNode = currentNode;\n      }\n    }\n  }\n}\n\nfunction getNeighbors(currentNode, grid) {\n  const neighborList = [];\n  const column = currentNode.column,\n        row = currentNode.row;\n  if (column > 0) neighborList.push(grid[column - 1][row]);\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\n  if (row > 0) neighborList.push(grid[column][row - 1]);\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\n  return neighborList;\n}\n\nfunction getClosestNode(unvisitedNodes) {\n  //arrange in ascending order by distance\n  unvisitedNodes.sort((A, B) => A.distance - B.distance); //remove closestNode from unvisited nodes\n\n  const node = unvisitedNodes.shift();\n  return node;\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const column of grid) {\n    for (const node of column) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport function getShortestPath(startNode, endNode) {\n  const shortestPath = [];\n  let currentNode = endNode; // while (currentNode !== startNode) {\n\n  for (let i = 0; i < 5; i++) {\n    shortestPath.push(currentNode);\n    currentNode = currentNode.previousNode;\n    console.log(currentNode);\n  } // }\n\n\n  console.log(shortestPath);\n  return shortestPath;\n}","map":{"version":3,"sources":["C:/Users/Anish/Documents/Projects/pathfinding/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodes","distance","unvisitedNodes","getAllNodes","length","currentNode","getClosestNode","neighborList","getNeighbors","isWall","Infinity","isVisited","push","neighbor","console","log","previousNode","column","row","sort","A","B","node","shift","nodes","getShortestPath","shortestPath","i"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length > 0) {\r\n    //   start at the start node and susequently get the closest neighbor\r\n    const currentNode = getClosestNode(unvisitedNodes);\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    if (currentNode.isWall) continue;\r\n    if (currentNode.distance === Infinity) return visitedNodes;\r\n    currentNode.isVisited = true;\r\n    visitedNodes.push(currentNode);\r\n    if (currentNode === endNode) return visitedNodes;\r\n    for (const neighbor of neighborList) {\r\n      let distance = currentNode.distance + 1;\r\n      console.log(distance);\r\n      if (distance < neighbor.distance) {\r\n        neighbor.distance = distance;\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n\r\nfunction getClosestNode(unvisitedNodes) {\r\n  //arrange in ascending order by distance\r\n  unvisitedNodes.sort((A, B) => A.distance - B.distance);\r\n  //remove closestNode from unvisited nodes\r\n  const node = unvisitedNodes.shift();\r\n  return node;\r\n}\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const column of grid) {\r\n    for (const node of column) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\nexport function getShortestPath(startNode, endNode) {\r\n  const shortestPath = [];\r\n  let currentNode = endNode;\r\n  // while (currentNode !== startNode) {\r\n  for (let i = 0; i < 5; i++) {\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n    console.log(currentNode);\r\n  }\r\n  // }\r\n  console.log(shortestPath);\r\n  return shortestPath;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}