{"ast":null,"code":"export function dijkstra(grid,startNode,endNode){var visitedNodes=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);while(unvisitedNodes.length>0){//   start at the start node and susequently get the closest neighbor\nvar currentNode=getClosestNode(unvisitedNodes);var neighborList=getNeighbors(currentNode,grid);if(currentNode.isWall)continue;if(currentNode.distance===Infinity)return visitedNodes;currentNode.isVisited=true;visitedNodes.push(currentNode);if(currentNode===endNode)return visitedNodes;var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=neighborList[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var neighbor=_step.value;var distance=currentNode.distance+1;if(distance<neighbor.distance){neighbor.distance=distance;neighbor.previousNode=currentNode;}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}}function getNeighbors(currentNode,grid){var neighborList=[];var column=currentNode.column,row=currentNode.row;if(column>0)neighborList.push(grid[column-1][row]);if(column<grid.length-1)neighborList.push(grid[column+1][row]);if(row>0)neighborList.push(grid[column][row-1]);if(row<grid[0].length-1)neighborList.push(grid[column][row+1]);return neighborList;}function getClosestNode(unvisitedNodes){//arrange in ascending order by distance\nunvisitedNodes.sort(function(A,B){return A.distance-B.distance;});//remove closestNode from unvisited nodes\nvar node=unvisitedNodes.shift();return node;}function getAllNodes(grid){var nodes=[];var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=grid[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var column=_step2.value;var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=column[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var node=_step3.value;nodes.push(node);}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally{try{if(!_iteratorNormalCompletion3&&_iterator3.return!=null){_iterator3.return();}}finally{if(_didIteratorError3){throw _iteratorError3;}}}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2.return!=null){_iterator2.return();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}return nodes;}export function getShortestPath(startNode,endNode){var shortestPath=[];var currentNode=endNode;while(currentNode!==null){shortestPath.push(currentNode);currentNode=currentNode.previousNode;}return shortestPath.reverse();}","map":{"version":3,"sources":["C:/Users/Anish/Documents/PROJECTS/pathfinding/pathfinder/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodes","distance","unvisitedNodes","getAllNodes","length","currentNode","getClosestNode","neighborList","getNeighbors","isWall","Infinity","isVisited","push","neighbor","previousNode","column","row","sort","A","B","node","shift","nodes","getShortestPath","shortestPath","reverse"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length > 0) {\r\n    //   start at the start node and susequently get the closest neighbor\r\n    const currentNode = getClosestNode(unvisitedNodes);\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    if (currentNode.isWall) continue;\r\n    if (currentNode.distance === Infinity) return visitedNodes;\r\n    currentNode.isVisited = true;\r\n    visitedNodes.push(currentNode);\r\n    if (currentNode === endNode) return visitedNodes;\r\n    for (const neighbor of neighborList) {\r\n      let distance = currentNode.distance + 1;\r\n      if (distance < neighbor.distance) {\r\n        neighbor.distance = distance;\r\n        neighbor.previousNode = currentNode;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n\r\nfunction getClosestNode(unvisitedNodes) {\r\n  //arrange in ascending order by distance\r\n  unvisitedNodes.sort((A, B) => A.distance - B.distance);\r\n  //remove closestNode from unvisited nodes\r\n  const node = unvisitedNodes.shift();\r\n  return node;\r\n}\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const column of grid) {\r\n    for (const node of column) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\nexport function getShortestPath(startNode, endNode) {\r\n  let shortestPath = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    shortestPath.push(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return shortestPath.reverse();\r\n}\r\n"]},"metadata":{},"sourceType":"module"}