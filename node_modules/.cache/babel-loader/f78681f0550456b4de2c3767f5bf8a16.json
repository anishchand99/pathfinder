{"ast":null,"code":"export function dfs(grid, startNode, endNode) {\n  const visitedNodes = [];\n  let stack = [startNode];\n  console.log(startNode);\n  console.log(stack);\n  let currentNode;\n\n  while (stack.length !== 0) {\n    currentNode = stack.pop();\n    if (currentNode.isWall) continue;\n\n    if (!visitedNodes.includes(currentNode)) {\n      visitedNodes.push(currentNode);\n    }\n\n    if (currentNode === endNode) return visitedNodes;\n    const neighborList = getNeighbors(currentNode, grid);\n\n    for (const node of neighborList) {\n      if (!visitedNodes.includes(node)) {\n        node.previousNode = currentNode;\n        stack.push(node);\n      }\n    }\n  }\n}\n\nfunction getNeighbors(currentNode, grid) {\n  const neighborList = [];\n  const column = currentNode.column,\n        row = currentNode.row;\n  if (column > 0) neighborList.push(grid[column - 1][row]);\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\n  if (row > 0) neighborList.push(grid[column][row - 1]);\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\n  return neighborList;\n}","map":{"version":3,"sources":["C:/Users/Anish/Documents/PROJECTS/pathfinding/pathfinder/src/algorithms/dfs.js"],"names":["dfs","grid","startNode","endNode","visitedNodes","stack","console","log","currentNode","length","pop","isWall","includes","push","neighborList","getNeighbors","node","previousNode","column","row"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,OAA9B,EAAuC;AAC5C,QAAMC,YAAY,GAAG,EAArB;AACA,MAAIC,KAAK,GAAG,CAACH,SAAD,CAAZ;AACAI,EAAAA,OAAO,CAACC,GAAR,CAAYL,SAAZ;AACAI,EAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACA,MAAIG,WAAJ;;AACA,SAAOH,KAAK,CAACI,MAAN,KAAiB,CAAxB,EAA2B;AACzBD,IAAAA,WAAW,GAAGH,KAAK,CAACK,GAAN,EAAd;AACA,QAAIF,WAAW,CAACG,MAAhB,EAAwB;;AACxB,QAAI,CAACP,YAAY,CAACQ,QAAb,CAAsBJ,WAAtB,CAAL,EAAyC;AACvCJ,MAAAA,YAAY,CAACS,IAAb,CAAkBL,WAAlB;AACD;;AACD,QAAIA,WAAW,KAAKL,OAApB,EAA6B,OAAOC,YAAP;AAC7B,UAAMU,YAAY,GAAGC,YAAY,CAACP,WAAD,EAAcP,IAAd,CAAjC;;AACA,SAAK,MAAMe,IAAX,IAAmBF,YAAnB,EAAiC;AAC/B,UAAI,CAACV,YAAY,CAACQ,QAAb,CAAsBI,IAAtB,CAAL,EAAkC;AAChCA,QAAAA,IAAI,CAACC,YAAL,GAAoBT,WAApB;AACAH,QAAAA,KAAK,CAACQ,IAAN,CAAWG,IAAX;AACD;AACF;AACF;AACF;;AAED,SAASD,YAAT,CAAsBP,WAAtB,EAAmCP,IAAnC,EAAyC;AACvC,QAAMa,YAAY,GAAG,EAArB;AADuC,QAE/BI,MAF+B,GAEfV,WAFe,CAE/BU,MAF+B;AAAA,QAEvBC,GAFuB,GAEfX,WAFe,CAEvBW,GAFuB;AAGvC,MAAID,MAAM,GAAG,CAAb,EAAgBJ,YAAY,CAACD,IAAb,CAAkBZ,IAAI,CAACiB,MAAM,GAAG,CAAV,CAAJ,CAAiBC,GAAjB,CAAlB;AAChB,MAAID,MAAM,GAAGjB,IAAI,CAACQ,MAAL,GAAc,CAA3B,EAA8BK,YAAY,CAACD,IAAb,CAAkBZ,IAAI,CAACiB,MAAM,GAAG,CAAV,CAAJ,CAAiBC,GAAjB,CAAlB;AAC9B,MAAIA,GAAG,GAAG,CAAV,EAAaL,YAAY,CAACD,IAAb,CAAkBZ,IAAI,CAACiB,MAAD,CAAJ,CAAaC,GAAG,GAAG,CAAnB,CAAlB;AACb,MAAIA,GAAG,GAAGlB,IAAI,CAAC,CAAD,CAAJ,CAAQQ,MAAR,GAAiB,CAA3B,EAA8BK,YAAY,CAACD,IAAb,CAAkBZ,IAAI,CAACiB,MAAD,CAAJ,CAAaC,GAAG,GAAG,CAAnB,CAAlB;AAC9B,SAAOL,YAAP;AACD","sourcesContent":["export function dfs(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  let stack = [startNode];\r\n  console.log(startNode);\r\n  console.log(stack);\r\n  let currentNode;\r\n  while (stack.length !== 0) {\r\n    currentNode = stack.pop();\r\n    if (currentNode.isWall) continue;\r\n    if (!visitedNodes.includes(currentNode)) {\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    if (currentNode === endNode) return visitedNodes;\r\n    const neighborList = getNeighbors(currentNode, grid);\r\n    for (const node of neighborList) {\r\n      if (!visitedNodes.includes(node)) {\r\n        node.previousNode = currentNode;\r\n        stack.push(node);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < grid.length - 1) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row < grid[0].length - 1) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}