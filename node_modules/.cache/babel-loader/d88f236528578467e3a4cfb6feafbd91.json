{"ast":null,"code":"import { START_NODE_COL, START_NODE_ROW, END_NODE_COL, END_NODE_ROW } from \"../constants\";\nexport function dijkstra(grid, startNode, endNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid); //   while (unvisitedNodes.length > 0) {\n  //   start at the start node and susequently get the closest neighbor\n\n  const currentNode = getClosestNode(unvisitedNodes);\n  console.log(currentNode);\n  const neighborList = getNeighbors(currentNode, grid); //   }\n}\n\nfunction getNeighbors(currentNode, grid) {\n  const neighborList = [];\n  const column = currentNode.column,\n        row = currentNode.row;\n  if (column > 0) neighborList.push(grid[column - 1][row]);\n  if (column < END_NODE_COL) neighborList.push(grid[column + 1][row]);\n  if (row > 0) neighborList.push(grid[column][row - 1]);\n  if (row > END_NODE_ROW) neighborList.push(grid[column][row + 1]);\n  return neighborList;\n}\n\nfunction getClosestNode(unvisitedNodes) {\n  //arrange in ascending order by distance\n  unvisitedNodes.sort((A, B) => A.distance - B.distance); //remove closestNode from unvisited nodes\n\n  const node = unvisitedNodes.shift();\n  return node;\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const column of grid) {\n    for (const node of column) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["C:/Users/Anish/Documents/Projects/pathfinding/src/algorithms/dijkstra.js"],"names":["START_NODE_COL","START_NODE_ROW","END_NODE_COL","END_NODE_ROW","dijkstra","grid","startNode","endNode","visitedNodes","distance","unvisitedNodes","getAllNodes","currentNode","getClosestNode","console","log","neighborList","getNeighbors","column","row","push","sort","A","B","node","shift","nodes"],"mappings":"AAAA,SACEA,cADF,EAEEC,cAFF,EAGEC,YAHF,EAIEC,YAJF,QAKO,cALP;AAMA,OAAO,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,OAAnC,EAA4C;AACjD,QAAMC,YAAY,GAAG,EAArB;AACAF,EAAAA,SAAS,CAACG,QAAV,GAAqB,CAArB;AACA,QAAMC,cAAc,GAAGC,WAAW,CAACN,IAAD,CAAlC,CAHiD,CAIjD;AACA;;AACA,QAAMO,WAAW,GAAGC,cAAc,CAACH,cAAD,CAAlC;AACAI,EAAAA,OAAO,CAACC,GAAR,CAAYH,WAAZ;AACA,QAAMI,YAAY,GAAGC,YAAY,CAACL,WAAD,EAAcP,IAAd,CAAjC,CARiD,CASjD;AACD;;AAED,SAASY,YAAT,CAAsBL,WAAtB,EAAmCP,IAAnC,EAAyC;AACvC,QAAMW,YAAY,GAAG,EAArB;AADuC,QAE/BE,MAF+B,GAEfN,WAFe,CAE/BM,MAF+B;AAAA,QAEvBC,GAFuB,GAEfP,WAFe,CAEvBO,GAFuB;AAGvC,MAAID,MAAM,GAAG,CAAb,EAAgBF,YAAY,CAACI,IAAb,CAAkBf,IAAI,CAACa,MAAM,GAAG,CAAV,CAAJ,CAAiBC,GAAjB,CAAlB;AAChB,MAAID,MAAM,GAAGhB,YAAb,EAA2Bc,YAAY,CAACI,IAAb,CAAkBf,IAAI,CAACa,MAAM,GAAG,CAAV,CAAJ,CAAiBC,GAAjB,CAAlB;AAC3B,MAAIA,GAAG,GAAG,CAAV,EAAaH,YAAY,CAACI,IAAb,CAAkBf,IAAI,CAACa,MAAD,CAAJ,CAAaC,GAAG,GAAG,CAAnB,CAAlB;AACb,MAAIA,GAAG,GAAGhB,YAAV,EAAwBa,YAAY,CAACI,IAAb,CAAkBf,IAAI,CAACa,MAAD,CAAJ,CAAaC,GAAG,GAAG,CAAnB,CAAlB;AACxB,SAAOH,YAAP;AACD;;AAED,SAASH,cAAT,CAAwBH,cAAxB,EAAwC;AACtC;AACAA,EAAAA,cAAc,CAACW,IAAf,CAAoB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACb,QAAF,GAAac,CAAC,CAACd,QAA7C,EAFsC,CAGtC;;AACA,QAAMe,IAAI,GAAGd,cAAc,CAACe,KAAf,EAAb;AACA,SAAOD,IAAP;AACD;;AACD,SAASb,WAAT,CAAqBN,IAArB,EAA2B;AACzB,QAAMqB,KAAK,GAAG,EAAd;;AACA,OAAK,MAAMR,MAAX,IAAqBb,IAArB,EAA2B;AACzB,SAAK,MAAMmB,IAAX,IAAmBN,MAAnB,EAA2B;AACzBQ,MAAAA,KAAK,CAACN,IAAN,CAAWI,IAAX;AACD;AACF;;AACD,SAAOE,KAAP;AACD","sourcesContent":["import {\r\n  START_NODE_COL,\r\n  START_NODE_ROW,\r\n  END_NODE_COL,\r\n  END_NODE_ROW\r\n} from \"../constants\";\r\nexport function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodes = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  //   while (unvisitedNodes.length > 0) {\r\n  //   start at the start node and susequently get the closest neighbor\r\n  const currentNode = getClosestNode(unvisitedNodes);\r\n  console.log(currentNode);\r\n  const neighborList = getNeighbors(currentNode, grid);\r\n  //   }\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid) {\r\n  const neighborList = [];\r\n  const { column, row } = currentNode;\r\n  if (column > 0) neighborList.push(grid[column - 1][row]);\r\n  if (column < END_NODE_COL) neighborList.push(grid[column + 1][row]);\r\n  if (row > 0) neighborList.push(grid[column][row - 1]);\r\n  if (row > END_NODE_ROW) neighborList.push(grid[column][row + 1]);\r\n  return neighborList;\r\n}\r\n\r\nfunction getClosestNode(unvisitedNodes) {\r\n  //arrange in ascending order by distance\r\n  unvisitedNodes.sort((A, B) => A.distance - B.distance);\r\n  //remove closestNode from unvisited nodes\r\n  const node = unvisitedNodes.shift();\r\n  return node;\r\n}\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const column of grid) {\r\n    for (const node of column) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}