{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Anish\\\\Documents\\\\PROJECTS\\\\pathfinding\\\\pathfinder\\\\src\\\\PathFinder\\\\PathFinder.js\";\nimport React, { Component } from 'react';\nimport Node from './Node.js';\nimport './PathFinder.css';\nimport Navbar from './Navbar';\nimport { bfs } from '../algorithms/bfs';\nimport { dfs } from '../algorithms/dfs';\nimport { dijkstra, getShortestPath } from '../algorithms/dijkstra';\nimport { START_NODE_COL, START_NODE_ROW, END_NODE_COL, END_NODE_ROW, GRID_COLS, GRID_ROWS } from '../constants';\n\nconst createWallDictionary = () => {\n  let wallDict = new Map();\n\n  for (let i = 0; i < GRID_COLS; i++) {\n    for (let j = 0; j < GRID_ROWS; j++) {\n      wallDict.set(\"\".concat(i, \"-\").concat(j), false);\n    }\n  }\n\n  return wallDict;\n};\n\nlet wallDictionary = createWallDictionary();\nconst initialState = {\n  grid: [],\n  startNodeCol: START_NODE_COL,\n  startNodeRow: START_NODE_ROW,\n  endNodeCol: END_NODE_COL,\n  endNodeRow: END_NODE_ROW,\n  algo: 'dijkstra',\n  speed: 500,\n  wallDict: wallDictionary\n};\n\nclass PathFinder extends Component {\n  constructor() {\n    super();\n\n    this.selectAlgo = algorithm => {\n      this.setState({\n        algo: algorithm\n      });\n    };\n\n    this.selectSpeed = speedX => {\n      this.setState({\n        speed: speedX\n      });\n    };\n\n    this.makeWall = node => {\n      const _this$state = this.state,\n            startNodeCol = _this$state.startNodeCol,\n            startNodeRow = _this$state.startNodeRow,\n            endNodeCol = _this$state.endNodeCol,\n            endNodeRow = _this$state.endNodeRow;\n      let updatedWall = this.state.wallDict; //check if the node is already a wall\n\n      const alreadyIsWall = this.state.wallDict.get(\"\".concat(node.props.column, \"-\").concat(node.props.row)); //check if condition: don't make wall if it is a start node or end node\n\n      if (!(node.props.row === startNodeRow && node.props.column === startNodeCol || node.props.row === endNodeRow && node.props.column === endNodeCol)) {\n        //check if condition: if already a wall, remove the wall\n        if (alreadyIsWall) {\n          updatedWall.set(\"\".concat(node.props.column, \"-\").concat(node.props.row), false);\n        } else {\n          updatedWall.set(\"\".concat(node.props.column, \"-\").concat(node.props.row), true);\n        }\n      }\n\n      this.setState({\n        wallDict: updatedWall\n      }, () => {\n        const grid = drawInitialGrid(this.state);\n        this.setState({\n          grid: grid\n        });\n      });\n    };\n\n    this.changeStartNode = node => {\n      this.setState({\n        startNodeCol: node.props.column,\n        startNodeRow: node.props.row\n      }, () => {\n        const grid = drawInitialGrid(this.state);\n        this.setState({\n          grid: grid\n        });\n      });\n    };\n\n    this.changeEndNode = node => {\n      this.setState({\n        endNodeCol: node.props.column,\n        endNodeRow: node.props.row\n      }, () => {\n        const grid = drawInitialGrid(this.state);\n        this.setState({\n          grid: grid\n        });\n      });\n    };\n\n    this.state = initialState;\n  }\n\n  componentDidMount() {\n    const grid = drawInitialGrid(this.state);\n    this.setState({\n      grid: grid\n    });\n  }\n\n  freezeButtons(bool) {\n    let startButton = document.getElementById('start');\n    startButton.disabled = bool;\n    let resetButton = document.getElementById('reset');\n    resetButton.disabled = bool;\n  }\n\n  visualizeAlgorithm() {\n    this.freezeButtons(true);\n    const _this$state2 = this.state,\n          grid = _this$state2.grid,\n          startNodeCol = _this$state2.startNodeCol,\n          startNodeRow = _this$state2.startNodeRow,\n          endNodeCol = _this$state2.endNodeCol,\n          endNodeRow = _this$state2.endNodeRow,\n          algo = _this$state2.algo;\n    const startNode = grid[startNodeCol][startNodeRow];\n    const endNode = grid[endNodeCol][endNodeRow];\n    let visitedNodes = [];\n\n    if (algo === 'dijkstra') {\n      visitedNodes = dijkstra(grid, startNode, endNode);\n      const shortestPath = getShortestPath(startNode, endNode);\n    } else if (algo === 'breadthFirst') {\n      visitedNodes = bfs(grid, startNode, endNode);\n      const shortestPath = getShortestPath(startNode, endNode);\n    } else if (algo === 'depthFirst') {\n      console.log('dfs');\n      visitedNodes = dfs(grid, startNode, endNode);\n      const shortestPath = visitedNodes;\n    } else {\n      const shortestPath = getShortestPath(startNode, endNode);\n    }\n\n    this.removeCSS();\n    this.animateAlgorithm(visitedNodes, startNode, endNode, shortestPath);\n  } //remove the CSS of the nodes after the first use of visualize button\n\n\n  removeCSS() {\n    while (document.querySelector(\".node-Visited\") != null || document.querySelector(\".node-Path\") != null) {\n      if (document.querySelector(\".node-Visited\") != null) {\n        document.querySelector(\".node-Visited\").className = 'node';\n      }\n\n      if (document.querySelector(\".node-Path\") != null) {\n        document.querySelector(\".node-Path\").className = 'node';\n      }\n    }\n  }\n\n  animateAlgorithm(visitedNodes, startNode, endNode, shortestPath) {\n    const speed = this.state.speed;\n\n    for (let i = 0; i < visitedNodes.length; i++) {\n      if (i === visitedNodes.length - 1) {\n        setTimeout(() => {\n          this.displayShortestPath(shortestPath, startNode, endNode);\n        }, speed * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodes[i];\n\n        if (node !== startNode && node !== endNode) {\n          document.getElementById(\"node-\".concat(node.column, \"-\").concat(node.row)).className = 'node-Visited';\n        }\n      }, speed * i);\n    }\n  }\n\n  displayShortestPath(shortestPath, startNode, endNode) {\n    for (let i = 0; i < shortestPath.length; i++) {\n      const node = shortestPath[i];\n\n      if (node !== startNode && node !== endNode) {\n        document.getElementById(\"node-\".concat(node.column, \"-\").concat(node.row)).className = 'node-Path';\n      }\n    }\n\n    this.freezeButtons(false);\n  }\n\n  //reset the CSS animations to go to fresh grid, used in the reset button\n  resetCSS() {\n    while (document.querySelector(\".node-Visited\") != null || document.querySelector(\".node-Path\") != null || document.querySelector(\".nodewall\") != null) {\n      if (document.querySelector(\".node-Visited\") != null) {\n        document.querySelector(\".node-Visited\").className = 'node';\n      }\n\n      if (document.querySelector(\".node-Path\") != null) {\n        document.querySelector(\".node-Path\").className = 'node';\n      }\n\n      if (document.querySelector(\".nodewall\") != null) {\n        document.querySelector(\".nodewall\").className = 'node';\n      }\n    }\n  }\n\n  render() {\n    const grid = this.state.grid;\n    return React.createElement(\"div\", {\n      className: \"container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 207\n      },\n      __self: this\n    }, React.createElement(Navbar, {\n      selectAlgo: this.selectAlgo,\n      selectSpeed: this.selectSpeed,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 208\n      },\n      __self: this\n    }), React.createElement(\"button\", {\n      id: \"start\",\n      onClick: () => this.visualizeAlgorithm(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 212\n      },\n      __self: this\n    }, \"Visualize!\"), React.createElement(\"button\", {\n      id: \"reset\",\n      onClick: () => this.resetCSS(),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 215\n      },\n      __self: this\n    }, \"Reset!\"), React.createElement(\"div\", {\n      className: \"grid\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 218\n      },\n      __self: this\n    }, grid.map((row, rowIndex) => {\n      return React.createElement(\"div\", {\n        key: rowIndex,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 221\n        },\n        __self: this\n      }, row.map((coln, colnIndex) => {\n        const row = coln.row,\n              column = coln.column,\n              isStart = coln.isStart,\n              isFinish = coln.isFinish,\n              isWall = coln.isWall;\n        return React.createElement(Node, {\n          key: colnIndex,\n          row: row,\n          column: column,\n          isFinish: isFinish,\n          isStart: isStart,\n          isWall: isWall,\n          changeStartNode: this.changeStartNode,\n          changeEndNode: this.changeEndNode,\n          makeWall: this.makeWall,\n          resetCSS: this.resetCSS,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 225\n          },\n          __self: this\n        });\n      }));\n    })));\n  }\n\n}\n\nconst drawInitialGrid = state => {\n  const grid = [];\n\n  for (let column = 0; column < GRID_COLS; column++) {\n    let currentColumn = [];\n\n    for (let row = 0; row < GRID_ROWS; row++) {\n      currentColumn.push(createNewNode(row, column, state));\n    }\n\n    grid.push(currentColumn);\n  }\n\n  return grid;\n};\n\nconst createNewNode = (row, column, state) => {\n  const startNodeCol = state.startNodeCol,\n        startNodeRow = state.startNodeRow,\n        endNodeCol = state.endNodeCol,\n        endNodeRow = state.endNodeRow,\n        wallDict = state.wallDict;\n  return {\n    column,\n    row,\n    distance: Infinity,\n    previousNode: null,\n    isVisited: false,\n    isWall: wallDict.get(\"\".concat(column, \"-\").concat(row)),\n    isStart: column === startNodeCol && row === startNodeRow,\n    isFinish: column === endNodeCol && row === endNodeRow\n  };\n};\n\nexport default PathFinder; //Try a boolean vs string dicitonary string will be the coln and row and boolean is isWall.","map":{"version":3,"sources":["C:/Users/Anish/Documents/PROJECTS/pathfinding/pathfinder/src/PathFinder/PathFinder.js"],"names":["React","Component","Node","Navbar","bfs","dfs","dijkstra","getShortestPath","START_NODE_COL","START_NODE_ROW","END_NODE_COL","END_NODE_ROW","GRID_COLS","GRID_ROWS","createWallDictionary","wallDict","Map","i","j","set","wallDictionary","initialState","grid","startNodeCol","startNodeRow","endNodeCol","endNodeRow","algo","speed","PathFinder","constructor","selectAlgo","algorithm","setState","selectSpeed","speedX","makeWall","node","state","updatedWall","alreadyIsWall","get","props","column","row","drawInitialGrid","changeStartNode","changeEndNode","componentDidMount","freezeButtons","bool","startButton","document","getElementById","disabled","resetButton","visualizeAlgorithm","startNode","endNode","visitedNodes","shortestPath","console","log","removeCSS","animateAlgorithm","querySelector","className","length","setTimeout","displayShortestPath","resetCSS","render","map","rowIndex","coln","colnIndex","isStart","isFinish","isWall","currentColumn","push","createNewNode","distance","Infinity","previousNode","isVisited"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport Node from './Node.js';\r\nimport './PathFinder.css';\r\nimport Navbar from './Navbar';\r\nimport { bfs } from '../algorithms/bfs';\r\nimport { dfs } from '../algorithms/dfs';\r\nimport { dijkstra, getShortestPath } from '../algorithms/dijkstra';\r\nimport {\r\n  START_NODE_COL,\r\n  START_NODE_ROW,\r\n  END_NODE_COL,\r\n  END_NODE_ROW,\r\n  GRID_COLS,\r\n  GRID_ROWS,\r\n} from '../constants';\r\nconst createWallDictionary = () => {\r\n  let wallDict = new Map();\r\n  for (let i = 0; i < GRID_COLS; i++) {\r\n    for (let j = 0; j < GRID_ROWS; j++) {\r\n      wallDict.set(`${i}-${j}`, false);\r\n    }\r\n  }\r\n  return wallDict;\r\n};\r\nlet wallDictionary = createWallDictionary();\r\nconst initialState = {\r\n  grid: [],\r\n  startNodeCol: START_NODE_COL,\r\n  startNodeRow: START_NODE_ROW,\r\n  endNodeCol: END_NODE_COL,\r\n  endNodeRow: END_NODE_ROW,\r\n  algo: 'dijkstra',\r\n  speed: 500,\r\n  wallDict: wallDictionary,\r\n};\r\nclass PathFinder extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = initialState;\r\n  }\r\n  componentDidMount() {\r\n    const grid = drawInitialGrid(this.state);\r\n    this.setState({ grid: grid });\r\n  }\r\n  freezeButtons(bool) {\r\n    let startButton = document.getElementById('start');\r\n    startButton.disabled = bool;\r\n    let resetButton = document.getElementById('reset');\r\n    resetButton.disabled = bool;\r\n  }\r\n  selectAlgo = (algorithm) => {\r\n    this.setState({ algo: algorithm });\r\n  };\r\n  selectSpeed = (speedX) => {\r\n    this.setState({ speed: speedX });\r\n  };\r\n  visualizeAlgorithm() {\r\n    this.freezeButtons(true);\r\n    const {\r\n      grid,\r\n      startNodeCol,\r\n      startNodeRow,\r\n      endNodeCol,\r\n      endNodeRow,\r\n      algo,\r\n    } = this.state;\r\n    const startNode = grid[startNodeCol][startNodeRow];\r\n    const endNode = grid[endNodeCol][endNodeRow];\r\n    let visitedNodes = [];\r\n    if (algo === 'dijkstra') {\r\n      visitedNodes = dijkstra(grid, startNode, endNode);\r\n      const shortestPath = getShortestPath(startNode, endNode);\r\n    } else if (algo === 'breadthFirst') {\r\n      visitedNodes = bfs(grid, startNode, endNode);\r\n      const shortestPath = getShortestPath(startNode, endNode);\r\n    } else if (algo === 'depthFirst') {\r\n      console.log('dfs');\r\n      visitedNodes = dfs(grid, startNode, endNode);\r\n      const shortestPath = visitedNodes;\r\n    } else {\r\n      const shortestPath = getShortestPath(startNode, endNode);\r\n    }\r\n    this.removeCSS();\r\n    this.animateAlgorithm(visitedNodes, startNode, endNode, shortestPath);\r\n  }\r\n\r\n  //remove the CSS of the nodes after the first use of visualize button\r\n  removeCSS() {\r\n    while (\r\n      document.querySelector(`.node-Visited`) != null ||\r\n      document.querySelector(`.node-Path`) != null\r\n    ) {\r\n      if (document.querySelector(`.node-Visited`) != null) {\r\n        document.querySelector(`.node-Visited`).className = 'node';\r\n      }\r\n      if (document.querySelector(`.node-Path`) != null) {\r\n        document.querySelector(`.node-Path`).className = 'node';\r\n      }\r\n    }\r\n  }\r\n  animateAlgorithm(visitedNodes, startNode, endNode, shortestPath) {\r\n    const { speed } = this.state;\r\n    for (let i = 0; i < visitedNodes.length; i++) {\r\n      if (i === visitedNodes.length - 1) {\r\n        setTimeout(() => {\r\n          this.displayShortestPath(shortestPath, startNode, endNode);\r\n        }, speed * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodes[i];\r\n        if (node !== startNode && node !== endNode) {\r\n          document.getElementById(`node-${node.column}-${node.row}`).className =\r\n            'node-Visited';\r\n        }\r\n      }, speed * i);\r\n    }\r\n  }\r\n  displayShortestPath(shortestPath, startNode, endNode) {\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n      const node = shortestPath[i];\r\n      if (node !== startNode && node !== endNode) {\r\n        document.getElementById(`node-${node.column}-${node.row}`).className =\r\n          'node-Path';\r\n      }\r\n    }\r\n    this.freezeButtons(false);\r\n  }\r\n  makeWall = (node) => {\r\n    const { startNodeCol, startNodeRow, endNodeCol, endNodeRow } = this.state;\r\n    let updatedWall = this.state.wallDict;\r\n    //check if the node is already a wall\r\n    const alreadyIsWall = this.state.wallDict.get(\r\n      `${node.props.column}-${node.props.row}`\r\n    );\r\n    //check if condition: don't make wall if it is a start node or end node\r\n    if (\r\n      !(\r\n        (node.props.row === startNodeRow &&\r\n          node.props.column === startNodeCol) ||\r\n        (node.props.row === endNodeRow && node.props.column === endNodeCol)\r\n      )\r\n    ) {\r\n      //check if condition: if already a wall, remove the wall\r\n      if (alreadyIsWall) {\r\n        updatedWall.set(`${node.props.column}-${node.props.row}`, false);\r\n      } else {\r\n        updatedWall.set(`${node.props.column}-${node.props.row}`, true);\r\n      }\r\n    }\r\n    this.setState(\r\n      {\r\n        wallDict: updatedWall,\r\n      },\r\n      () => {\r\n        const grid = drawInitialGrid(this.state);\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  };\r\n  changeStartNode = (node) => {\r\n    this.setState(\r\n      {\r\n        startNodeCol: node.props.column,\r\n        startNodeRow: node.props.row,\r\n      },\r\n      () => {\r\n        const grid = drawInitialGrid(this.state);\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  };\r\n  changeEndNode = (node) => {\r\n    this.setState(\r\n      {\r\n        endNodeCol: node.props.column,\r\n        endNodeRow: node.props.row,\r\n      },\r\n      () => {\r\n        const grid = drawInitialGrid(this.state);\r\n        this.setState({ grid: grid });\r\n      }\r\n    );\r\n  };\r\n\r\n  //reset the CSS animations to go to fresh grid, used in the reset button\r\n  resetCSS() {\r\n    while (\r\n      document.querySelector(`.node-Visited`) != null ||\r\n      document.querySelector(`.node-Path`) != null ||\r\n      document.querySelector(`.nodewall`) != null\r\n    ) {\r\n      if (document.querySelector(`.node-Visited`) != null) {\r\n        document.querySelector(`.node-Visited`).className = 'node';\r\n      }\r\n      if (document.querySelector(`.node-Path`) != null) {\r\n        document.querySelector(`.node-Path`).className = 'node';\r\n      }\r\n      if (document.querySelector(`.nodewall`) != null) {\r\n        document.querySelector(`.nodewall`).className = 'node';\r\n      }\r\n    }\r\n  }\r\n  render() {\r\n    const { grid } = this.state;\r\n    return (\r\n      <div className='container'>\r\n        <Navbar\r\n          selectAlgo={this.selectAlgo}\r\n          selectSpeed={this.selectSpeed}\r\n        ></Navbar>\r\n        <button id='start' onClick={() => this.visualizeAlgorithm()}>\r\n          Visualize!\r\n        </button>\r\n        <button id='reset' onClick={() => this.resetCSS()}>\r\n          Reset!\r\n        </button>\r\n        <div className='grid'>\r\n          {grid.map((row, rowIndex) => {\r\n            return (\r\n              <div key={rowIndex}>\r\n                {row.map((coln, colnIndex) => {\r\n                  const { row, column, isStart, isFinish, isWall } = coln;\r\n                  return (\r\n                    <Node\r\n                      key={colnIndex}\r\n                      row={row}\r\n                      column={column}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      changeStartNode={this.changeStartNode}\r\n                      changeEndNode={this.changeEndNode}\r\n                      makeWall={this.makeWall}\r\n                      resetCSS={this.resetCSS}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst drawInitialGrid = (state) => {\r\n  const grid = [];\r\n  for (let column = 0; column < GRID_COLS; column++) {\r\n    let currentColumn = [];\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n      currentColumn.push(createNewNode(row, column, state));\r\n    }\r\n    grid.push(currentColumn);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNewNode = (row, column, state) => {\r\n  const {\r\n    startNodeCol,\r\n    startNodeRow,\r\n    endNodeCol,\r\n    endNodeRow,\r\n    wallDict,\r\n  } = state;\r\n  return {\r\n    column,\r\n    row,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n    isVisited: false,\r\n    isWall: wallDict.get(`${column}-${row}`),\r\n    isStart: column === startNodeCol && row === startNodeRow,\r\n    isFinish: column === endNodeCol && row === endNodeRow,\r\n  };\r\n};\r\n\r\nexport default PathFinder;\r\n\r\n//Try a boolean vs string dicitonary string will be the coln and row and boolean is isWall.\r\n"]},"metadata":{},"sourceType":"module"}